<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module Sprockets::Loader - sprockets-3.7.1 Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="DigestUtils.html">Sprockets::DigestUtils</a>
  
  
  
    <li><a class="include" href="PathUtils.html">Sprockets::PathUtils</a>
  
  
  
    <li><a class="include" href="ProcessorUtils.html">Sprockets::ProcessorUtils</a>
  
  
  
    <li><a class="include" href="URIUtils.html">Sprockets::URIUtils</a>
  
  
  
    <li><a class="include" href="Engines.html">Sprockets::Engines</a>
  
  
  
    <li><a class="include" href="Mime.html">Sprockets::Mime</a>
  
  
  
    <li><a class="include" href="Processing.html">Sprockets::Processing</a>
  
  
  
    <li><a class="include" href="Resolve.html">Sprockets::Resolve</a>
  
  
  
    <li><a class="include" href="Transformers.html">Sprockets::Transformers</a>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-asset_from_cache">#asset_from_cache</a>
    
    <li ><a href="#method-i-fetch_asset_from_dependency_cache">#fetch_asset_from_dependency_cache</a>
    
    <li ><a href="#method-i-load">#load</a>
    
    <li ><a href="#method-i-load_from_unloaded">#load_from_unloaded</a>
    
    <li ><a href="#method-i-resolve_dependencies">#resolve_dependencies</a>
    
    <li ><a href="#method-i-store_asset">#store_asset</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-Sprockets::Loader">
  <h1 id="module-Sprockets::Loader" class="module">
    module Sprockets::Loader
  </h1>

  <section class="description">
    
<p>The loader phase takes a asset URI location and returns a constructed <a
href="Asset.html">Asset</a> object.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-load" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">load</span><span
            class="method-args">(uri)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Public: Load <a href="Asset.html">Asset</a> by <a
href="Asset.html">Asset</a> URI.</p>

<p>uri - A String containing complete URI to a file including schema</p>

<pre>and full path such as:
&quot;file:///Path/app/assets/js/app.js?type=application/javascript&quot;</pre>

<p>Returns <a href="Asset.html">Asset</a>.</p>
          
          

          
          <div class="method-source-code" id="load-source">
            <pre><span class="ruby-comment"># File lib/sprockets/loader.rb, line 32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load</span>(<span class="ruby-identifier">uri</span>)
  <span class="ruby-identifier">unloaded</span> = <span class="ruby-constant">UnloadedAsset</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">uri</span>, <span class="ruby-keyword">self</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">params</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-value">:id</span>)
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">asset</span> = <span class="ruby-identifier">asset_from_cache</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">asset_key</span>)
      <span class="ruby-identifier">id</span> = <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">params</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:id</span>)
      <span class="ruby-identifier">uri_without_id</span> = <span class="ruby-identifier">build_asset_uri</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">params</span>)
      <span class="ruby-identifier">asset</span> = <span class="ruby-identifier">load_from_unloaded</span>(<span class="ruby-constant">UnloadedAsset</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">uri_without_id</span>, <span class="ruby-keyword">self</span>))
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span>[<span class="ruby-value">:id</span>] <span class="ruby-operator">!=</span> <span class="ruby-identifier">id</span>
        <span class="ruby-ivar">@logger</span>.<span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;Sprockets load error: Tried to find #{uri}, but latest was id #{asset[:id]}&quot;</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">asset</span> = <span class="ruby-identifier">fetch_asset_from_dependency_cache</span>(<span class="ruby-identifier">unloaded</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">paths</span><span class="ruby-operator">|</span>
      <span class="ruby-comment"># When asset is previously generated, its &quot;dependencies&quot; are stored in the cache.</span>
      <span class="ruby-comment"># The presence of `paths` indicates dependencies were stored.</span>
      <span class="ruby-comment"># We can check to see if the dependencies have not changed by &quot;resolving&quot; them and</span>
      <span class="ruby-comment"># generating a digest key from the resolved entries. If this digest key has not</span>
      <span class="ruby-comment"># changed the asset will be pulled from cache.</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-comment"># If this `paths` is present but the cache returns nothing then `fetch_asset_from_dependency_cache`</span>
      <span class="ruby-comment"># will confusingly be called again with `paths` set to nil where the asset will be</span>
      <span class="ruby-comment"># loaded from disk.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">paths</span>
        <span class="ruby-identifier">digest</span> = <span class="ruby-constant">DigestUtils</span>.<span class="ruby-identifier">digest</span>(<span class="ruby-identifier">resolve_dependencies</span>(<span class="ruby-identifier">paths</span>))
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">uri_from_cache</span> = <span class="ruby-identifier">cache</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">digest_key</span>(<span class="ruby-identifier">digest</span>), <span class="ruby-keyword">true</span>)
          <span class="ruby-identifier">asset_from_cache</span>(<span class="ruby-constant">UnloadedAsset</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">uri_from_cache</span>, <span class="ruby-keyword">self</span>).<span class="ruby-identifier">asset_key</span>)
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">load_from_unloaded</span>(<span class="ruby-identifier">unloaded</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-constant">Asset</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">asset</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="private-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Private Instance Methods</h3>
       </header>

    
      <div id="method-i-asset_from_cache" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">asset_from_cache</span><span
            class="method-args">(key)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Internal: Load asset hash from cache</p>

<p>key - A String containing lookup information for an asset</p>

<p>This method converts all “compressed” paths to absolute paths. Returns a
hash of values representing an asset</p>
          
          

          
          <div class="method-source-code" id="asset_from_cache-source">
            <pre><span class="ruby-comment"># File lib/sprockets/loader.rb, line 75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">asset_from_cache</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">asset</span> = <span class="ruby-identifier">cache</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">key</span>, <span class="ruby-keyword">true</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span>
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:uri</span>]       = <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:uri</span>])
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:load_path</span>] = <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:load_path</span>])
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:filename</span>]  = <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:filename</span>])
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:included</span>].<span class="ruby-identifier">map!</span>          { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">uri</span>) } <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:included</span>]
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:links</span>].<span class="ruby-identifier">map!</span>             { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">uri</span>) } <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:links</span>]
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:stubbed</span>].<span class="ruby-identifier">map!</span>           { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">uri</span>) } <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:stubbed</span>]
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:required</span>].<span class="ruby-identifier">map!</span>          { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">uri</span>) } <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:required</span>]
    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">map!</span>      { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&quot;file-digest://&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">uri</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">uri</span> } <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>]

    <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>].<span class="ruby-identifier">each_key</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/_dependencies\z/</span>
      <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-identifier">k</span>].<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">uri</span>) }
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">asset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fetch_asset_from_dependency_cache" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fetch_asset_from_dependency_cache</span><span
            class="method-args">(unloaded, limit = 3) { |expanded_deps| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Internal: Retrieves an asset based on its digest</p>

<p>unloaded - An <a href="UnloadedAsset.html">UnloadedAsset</a> limit    - A
Fixnum which sets the maximum number of versions of “histories”</p>

<pre>stored in the cache</pre>

<p>This method attempts to retrieve the last `limit` number of histories of an
asset from the cache a “history” which is an array of unresolved
“dependencies” that the asset needs to compile. In this case A dependency
can refer to either an asset i.e. index.js may rely on jquery.js (so
jquery.js is a depndency), or other factors that may affect compilation,
such as the VERSION of sprockets (i.e. the environment) and what
“processors” are used.</p>

<p>For example a history array may look something like this</p>

<pre class="ruby">[[<span class="ruby-string">&quot;environment-version&quot;</span>, <span class="ruby-string">&quot;environment-paths&quot;</span>, <span class="ruby-string">&quot;processors:type=text/css&amp;file_type=text/css&quot;</span>,
  <span class="ruby-string">&quot;file-digest:///Full/path/app/assets/stylesheets/application.css&quot;</span>,
  <span class="ruby-string">&quot;processors:type=text/css&amp;file_digesttype=text/css&amp;pipeline=self&quot;</span>,
  <span class="ruby-string">&quot;file-digest:///Full/path/app/assets/stylesheets&quot;</span>]]
</pre>

<p>Where the first entry is a Set of dependencies for last generated version
of that asset. Multiple versions are stored since sprockets keeps the last
`limit` number of assets generated present in the system.</p>

<p>If a “history” of dependencies is present in the cache, each version of
“history” will be yielded to the passed block which is responsible for
loading the asset. If found, the existing history will be saved with the
dependency that found a valid asset moved to the front.</p>

<p>If no history is present, or if none of the histories could be resolved to
a valid asset then, the block is yielded to and expected to return a valid
asset. When this happens the dependencies for the returned asset are added
to the “history”, and older entries are removed if the “history” is above
`limit`.</p>
          
          

          
          <div class="method-source-code" id="fetch_asset_from_dependency_cache-source">
            <pre><span class="ruby-comment"># File lib/sprockets/loader.rb, line 303</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">fetch_asset_from_dependency_cache</span>(<span class="ruby-identifier">unloaded</span>, <span class="ruby-identifier">limit</span> = <span class="ruby-value">3</span>)
  <span class="ruby-identifier">key</span> = <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">dependency_history_key</span>

  <span class="ruby-identifier">history</span> = <span class="ruby-identifier">cache</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">key</span>) <span class="ruby-operator">||</span> []
  <span class="ruby-identifier">history</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">deps</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">expanded_deps</span> = <span class="ruby-identifier">deps</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">path</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">path</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&quot;file-digest://&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">expand_from_root</span>(<span class="ruby-identifier">path</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">path</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">asset</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">expanded_deps</span>)
      <span class="ruby-identifier">cache</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">history</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-identifier">index</span>)) <span class="ruby-keyword">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">asset</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">asset</span> = <span class="ruby-keyword">yield</span>
  <span class="ruby-identifier">deps</span>  = <span class="ruby-identifier">asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">map!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&quot;file-digest://&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">uri</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">uri</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">cache</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">history</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">deps</span>).<span class="ruby-identifier">take</span>(<span class="ruby-identifier">limit</span>))
  <span class="ruby-identifier">asset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-load_from_unloaded" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">load_from_unloaded</span><span
            class="method-args">(unloaded)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Internal: Loads an asset and saves it to cache</p>

<p>unloaded - An <a href="UnloadedAsset.html">UnloadedAsset</a></p>

<p>This method is only called when the given unloaded asset could not be
successfully pulled from cache.</p>
          
          

          
          <div class="method-source-code" id="load_from_unloaded-source">
            <pre><span class="ruby-comment"># File lib/sprockets/loader.rb, line 101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_from_unloaded</span>(<span class="ruby-identifier">unloaded</span>)
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">file?</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">FileNotFound</span>, <span class="ruby-node">&quot;could not find file: #{unloaded.filename}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">load_path</span>, <span class="ruby-identifier">logical_path</span> = <span class="ruby-identifier">paths_split</span>(<span class="ruby-identifier">config</span>[<span class="ruby-value">:paths</span>], <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>)

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">load_path</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">FileOutsidePaths</span>, <span class="ruby-node">&quot;#{unloaded.filename} is no longer under a load path: #{self.paths.join(&#39;, &#39;)}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">logical_path</span>, <span class="ruby-identifier">file_type</span>, <span class="ruby-identifier">engine_extnames</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_path_extnames</span>(<span class="ruby-identifier">logical_path</span>)
  <span class="ruby-identifier">name</span> = <span class="ruby-identifier">logical_path</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">pipeline</span> = <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">params</span>[<span class="ruby-value">:pipeline</span>]
    <span class="ruby-identifier">logical_path</span> <span class="ruby-operator">+=</span> <span class="ruby-node">&quot;.#{pipeline}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span> = <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">params</span>[<span class="ruby-value">:type</span>]
    <span class="ruby-identifier">logical_path</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">config</span>[<span class="ruby-value">:mime_types</span>][<span class="ruby-identifier">type</span>][<span class="ruby-value">:extensions</span>].<span class="ruby-identifier">first</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">file_type</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">config</span>[<span class="ruby-value">:transformers</span>][<span class="ruby-identifier">file_type</span>][<span class="ruby-identifier">type</span>]
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConversionError</span>, <span class="ruby-node">&quot;could not convert #{file_type.inspect} to #{type.inspect}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">processors</span> = <span class="ruby-identifier">processors_for</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">file_type</span>, <span class="ruby-identifier">engine_extnames</span>, <span class="ruby-identifier">pipeline</span>)

  <span class="ruby-identifier">processors_dep_uri</span> = <span class="ruby-identifier">build_processors_uri</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">file_type</span>, <span class="ruby-identifier">engine_extnames</span>, <span class="ruby-identifier">pipeline</span>)
  <span class="ruby-identifier">dependencies</span> = <span class="ruby-identifier">config</span>[<span class="ruby-value">:dependencies</span>] <span class="ruby-operator">+</span> [<span class="ruby-identifier">processors_dep_uri</span>]

  <span class="ruby-comment"># Read into memory and process if theres a processor pipeline</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">processors</span>.<span class="ruby-identifier">any?</span>
    <span class="ruby-identifier">result</span> = <span class="ruby-identifier">call_processors</span>(<span class="ruby-identifier">processors</span>, {
      <span class="ruby-identifier">environment</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>,
      <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cache</span>,
      <span class="ruby-identifier">uri</span><span class="ruby-operator">:</span> <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">uri</span>,
      <span class="ruby-identifier">filename</span><span class="ruby-operator">:</span> <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>,
      <span class="ruby-identifier">load_path</span><span class="ruby-operator">:</span> <span class="ruby-identifier">load_path</span>,
      <span class="ruby-identifier">name</span><span class="ruby-operator">:</span> <span class="ruby-identifier">name</span>,
      <span class="ruby-identifier">content_type</span><span class="ruby-operator">:</span> <span class="ruby-identifier">type</span>,
      <span class="ruby-identifier">metadata</span><span class="ruby-operator">:</span> { <span class="ruby-identifier">dependencies</span><span class="ruby-operator">:</span> <span class="ruby-identifier">dependencies</span> }
    })
    <span class="ruby-identifier">validate_processor_result!</span>(<span class="ruby-identifier">result</span>)
    <span class="ruby-identifier">source</span> = <span class="ruby-identifier">result</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:data</span>)
    <span class="ruby-identifier">metadata</span> = <span class="ruby-identifier">result</span>
    <span class="ruby-identifier">metadata</span>[<span class="ruby-value">:charset</span>] = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">encoding</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">metadata</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-value">:charset</span>)
    <span class="ruby-identifier">metadata</span>[<span class="ruby-value">:digest</span>]  = <span class="ruby-identifier">digest</span>(<span class="ruby-identifier">source</span>)
    <span class="ruby-identifier">metadata</span>[<span class="ruby-value">:length</span>]  = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">bytesize</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">dependencies</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">build_file_digest_uri</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>)
    <span class="ruby-identifier">metadata</span> = {
      <span class="ruby-identifier">digest</span><span class="ruby-operator">:</span> <span class="ruby-identifier">file_digest</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>),
      <span class="ruby-identifier">length</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stat</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>).<span class="ruby-identifier">size</span>,
      <span class="ruby-identifier">dependencies</span><span class="ruby-operator">:</span> <span class="ruby-identifier">dependencies</span>
    }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">asset</span> = {
    <span class="ruby-identifier">uri</span><span class="ruby-operator">:</span> <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">uri</span>,
    <span class="ruby-identifier">load_path</span><span class="ruby-operator">:</span> <span class="ruby-identifier">load_path</span>,
    <span class="ruby-identifier">filename</span><span class="ruby-operator">:</span> <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>,
    <span class="ruby-identifier">name</span><span class="ruby-operator">:</span> <span class="ruby-identifier">name</span>,
    <span class="ruby-identifier">logical_path</span><span class="ruby-operator">:</span> <span class="ruby-identifier">logical_path</span>,
    <span class="ruby-identifier">content_type</span><span class="ruby-operator">:</span> <span class="ruby-identifier">type</span>,
    <span class="ruby-identifier">source</span><span class="ruby-operator">:</span> <span class="ruby-identifier">source</span>,
    <span class="ruby-identifier">metadata</span><span class="ruby-operator">:</span> <span class="ruby-identifier">metadata</span>,
    <span class="ruby-identifier">dependencies_digest</span><span class="ruby-operator">:</span> <span class="ruby-constant">DigestUtils</span>.<span class="ruby-identifier">digest</span>(<span class="ruby-identifier">resolve_dependencies</span>(<span class="ruby-identifier">metadata</span>[<span class="ruby-value">:dependencies</span>]))
  }

  <span class="ruby-identifier">asset</span>[<span class="ruby-value">:id</span>]  = <span class="ruby-identifier">pack_hexdigest</span>(<span class="ruby-identifier">digest</span>(<span class="ruby-identifier">asset</span>))
  <span class="ruby-identifier">asset</span>[<span class="ruby-value">:uri</span>] = <span class="ruby-identifier">build_asset_uri</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">params</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">id</span><span class="ruby-operator">:</span> <span class="ruby-identifier">asset</span>[<span class="ruby-value">:id</span>]))

  <span class="ruby-comment"># Deprecated: Avoid tracking Asset mtime</span>
  <span class="ruby-identifier">asset</span>[<span class="ruby-value">:mtime</span>] = <span class="ruby-identifier">metadata</span>[<span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">u</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">u</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&quot;file-digest:&quot;</span>)
      <span class="ruby-identifier">s</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stat</span>(<span class="ruby-identifier">parse_file_digest_uri</span>(<span class="ruby-identifier">u</span>))
      <span class="ruby-identifier">s</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">mtime</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
  }.<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">max</span>
  <span class="ruby-identifier">asset</span>[<span class="ruby-value">:mtime</span>] <span class="ruby-operator">||=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stat</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">filename</span>).<span class="ruby-identifier">mtime</span>.<span class="ruby-identifier">to_i</span>

  <span class="ruby-identifier">store_asset</span>(<span class="ruby-identifier">asset</span>, <span class="ruby-identifier">unloaded</span>)
  <span class="ruby-identifier">asset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-resolve_dependencies" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">resolve_dependencies</span><span
            class="method-args">(uris)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Internal: <a href="Resolve.html">Resolve</a> set of dependency URIs.</p>

<p>uris - An Array of “dependencies” for example:</p>

<pre class="ruby">[<span class="ruby-string">&quot;environment-version&quot;</span>, <span class="ruby-string">&quot;environment-paths&quot;</span>, <span class="ruby-string">&quot;processors:type=text/css&amp;file_type=text/css&quot;</span>,
   <span class="ruby-string">&quot;file-digest:///Full/path/app/assets/stylesheets/application.css&quot;</span>,
   <span class="ruby-string">&quot;processors:type=text/css&amp;file_type=text/css&amp;pipeline=self&quot;</span>,
   <span class="ruby-string">&quot;file-digest:///Full/path/app/assets/stylesheets&quot;</span>]
</pre>

<p>Returns back array of things that the given uri dpends on For example the
environment version, if you&#39;re using a different version of sprockets
then the dependencies should be different, this is used only for generating
cache key for example the “environment-version” may be resolved to
“environment-1.0-3.2.0” for</p>

<pre>version &quot;3.2.0&quot; of sprockets.</pre>

<p>Any paths that are returned are converted to relative paths</p>

<p>Returns array of resolved dependencies</p>
          
          

          
          <div class="method-source-code" id="resolve_dependencies-source">
            <pre><span class="ruby-comment"># File lib/sprockets/loader.rb, line 267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">resolve_dependencies</span>(<span class="ruby-identifier">uris</span>)
  <span class="ruby-identifier">uris</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">resolve_dependency</span>(<span class="ruby-identifier">uri</span>) }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-store_asset" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">store_asset</span><span
            class="method-args">(asset, unloaded)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Internal: Save a given asset to the cache</p>

<p>asset - A hash containing values of loaded asset unloaded - The <a
href="UnloadedAsset.html">UnloadedAsset</a> used to lookup the `asset`</p>

<p>This method converts all absolute paths to “compressed” paths which are
relative if they&#39;re in the root.</p>
          
          

          
          <div class="method-source-code" id="store_asset-source">
            <pre><span class="ruby-comment"># File lib/sprockets/loader.rb, line 196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">store_asset</span>(<span class="ruby-identifier">asset</span>, <span class="ruby-identifier">unloaded</span>)
  <span class="ruby-comment"># Save the asset in the cache under the new URI</span>
  <span class="ruby-identifier">cached_asset</span>             = <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">dup</span>
  <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:uri</span>]       = <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:uri</span>])
  <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:filename</span>]  = <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:filename</span>])
  <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:load_path</span>] = <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:load_path</span>])

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>]
    <span class="ruby-comment"># Deep dup to avoid modifying `asset`</span>
    <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>] = <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>].<span class="ruby-identifier">dup</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:included</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:included</span>].<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:included</span>] = <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:included</span>].<span class="ruby-identifier">dup</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:included</span>].<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">uri</span>) }
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:links</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:links</span>].<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:links</span>] = <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:links</span>].<span class="ruby-identifier">dup</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:links</span>].<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">uri</span>) }
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:stubbed</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:stubbed</span>].<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:stubbed</span>] = <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:stubbed</span>].<span class="ruby-identifier">dup</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:stubbed</span>].<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">uri</span>) }
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:required</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:required</span>].<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:required</span>] = <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:required</span>].<span class="ruby-identifier">dup</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:required</span>].<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">uri</span>) }
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>] = <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">dup</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">map!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&quot;file-digest://&quot;</span>.<span class="ruby-identifier">freeze</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">uri</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">uri</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># compress all _dependencies in metadata like `sass_dependencies`</span>
    <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">key</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/_dependencies\z/</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">dup</span>
      <span class="ruby-identifier">cached_asset</span>[<span class="ruby-value">:metadata</span>][<span class="ruby-identifier">key</span>].<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">uri</span><span class="ruby-operator">|</span> <span class="ruby-identifier">compress_from_root</span>(<span class="ruby-identifier">uri</span>) }
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Unloaded asset and stored_asset now have a different URI</span>
  <span class="ruby-identifier">stored_asset</span> = <span class="ruby-constant">UnloadedAsset</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:uri</span>], <span class="ruby-keyword">self</span>)
  <span class="ruby-identifier">cache</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">stored_asset</span>.<span class="ruby-identifier">asset_key</span>, <span class="ruby-identifier">cached_asset</span>, <span class="ruby-keyword">true</span>)

  <span class="ruby-comment"># Save the new relative path for the digest key of the unloaded asset</span>
  <span class="ruby-identifier">cache</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">unloaded</span>.<span class="ruby-identifier">digest_key</span>(<span class="ruby-identifier">asset</span>[<span class="ruby-value">:dependencies_digest</span>]), <span class="ruby-identifier">stored_asset</span>.<span class="ruby-identifier">compressed_path</span>, <span class="ruby-keyword">true</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

